# ---------------------------------------------------------------------------
# DeepPruner: Learning Efficient Stereo Matching via Differentiable PatchMatch
#
# Copyright (c) 2019 Uber Technologies, Inc.
#
# Licensed under the Uber Non-Commercial License (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at the root directory of this project. 
#
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Written by Shivam Duggal
# ---------------------------------------------------------------------------

from __future__ import print_function
import re
import numpy as np
import sys
import chardet 

# def readPFM(file):
#     file = open(file, 'rb')

#     color = None
#     width = None
#     height = None
#     scale = None
#     endian = None

#     header = file.readline().rstrip()
#     encode_type = chardet.detect(header)  
#     header = header.decode(encode_type['encoding'])
#     print(header)
#     if header == 'PF':
#         color = True
#     elif header == 'Pf':
#         color = False
#     else:
#         raise Exception('Not a PFM file.')

#     dim_match = re.match(r'^(\d+)\s(\d+)\s$', file.readline())
#     if dim_match:
#         width, height = map(int, dim_match.groups())
#     else:
#         raise Exception('Malformed PFM header.')

#     scale = float(file.readline().rstrip())
#     if scale < 0:  # little-endian
#         endian = '<'
#         scale = -scale
#     else:
#         endian = '>'  # big-endian

#     data = np.fromfile(file, endian + 'f')
#     shape = (height, width, 3) if color else (height, width)

#     data = np.reshape(data, shape)
#     data = np.flipud(data)
#     return data, scale


def readPFM(file):
    file = open(file, 'rb')

    color = None
    width = None
    height = None
    scale = None
    endian = None

    header = file.readline().rstrip()
    encode_type = chardet.detect(header)  
    header = header.decode(encode_type['encoding'])
    if header == 'PF':
        color = True
    elif header == 'Pf':
        color = False
    else:
        raise Exception('Not a PFM file.')

    dim_match = re.match(r'^(\d+)\s(\d+)\s$', file.readline().decode(encode_type['encoding']))
    if dim_match:
        width, height = map(int, dim_match.groups())
    else:
        raise Exception('Malformed PFM header.')

    scale = float(file.readline().rstrip().decode(encode_type['encoding']))
    if scale < 0: # little-endian
        endian = '<'
        scale = -scale
    else:
        endian = '>' # big-endian

    data = np.fromfile(file, endian + 'f')
    shape = (height, width, 3) if color else (height, width)

    data = np.reshape(data, shape)
    data = np.flipud(data)
    return data, scale
